

""""
put *global* in front of a variable to make it global from inside a function
.strip() removes whitespace in a string
.upper() and .lower() to convert string to upper and lowercase respectively
complex(n) to convert n to a complex number
txt.replace('H', 'J') replaces all H characters to J characters in txt string
you can insert {} in a string as a placeholder and use txt.format() to insert into the string where {} is
the .insert(x, var) inserts var at the xth index in a list
the .remove(var) removes the var from a list or set
tuples are in (), lists are in [], sets and dicts are in {}
.append(var) to add var to a list, .add(var) to add var to a set
the .update(list) will add the values in list onto a set (for adding to lists .extend() works)
dict.get(key) will get the value at the key in a dictionary; dict[key] = value
dict.clear() will clear the entire dictionary (not delete)
print("Yes") if 5 > 2 else print("No") -> this is the conditional version
you can add an else: after a while loop to print once the while condition is false
for x in range(n) will iterate the for loop n times
if you are passing an unknown number of an arguments, insert an asterisk -> def my_function(*args):
for an unknown number of keyword arguments, use a double asterisk def my_function(**kids):
lambdas: x = lambda a, b, c : a + b + c -> takes in 3 arguments and sums them
you always need the *self* parameter for each defined function's first parameter in a class
if you have a class that is empty, put in the statement *pass* to avoid any errors
The child's __init__() function overrides the inheritance of the parent's __init__() function.
The super() function can be used to inherit the methods and properties of the parent class
The dir() function goes through all the function and variable names in a module

"""

